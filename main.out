\BOOKMARK [0][-]{section*.1}{Table des mati\350res}{}% 1
\BOOKMARK [0][-]{chapter.1}{Introduction}{}% 2
\BOOKMARK [1][-]{section.1.1}{Pourquoi la v\351rification et la preuve de programmes?}{chapter.1}% 3
\BOOKMARK [1][-]{section.1.2}{La r\351\351criture pour mod\351liser les programmes}{chapter.1}% 4
\BOOKMARK [1][-]{section.1.3}{V\351rification de syst\350mes de r\351\351criture}{chapter.1}% 5
\BOOKMARK [1][-]{section.1.4}{Pr\351sentation des contributions de cette th\350se}{chapter.1}% 6
\BOOKMARK [0][-]{chapter.2}{Pr\351requis}{}% 7
\BOOKMARK [1][-]{section.2.1}{Termes et r\351\351criture}{chapter.2}% 8
\BOOKMARK [1][-]{section.2.2}{Les automates d'arbres}{chapter.2}% 9
\BOOKMARK [1][-]{section.2.3}{Le Model-Checking r\351gulier}{chapter.2}% 10
\BOOKMARK [1][-]{section.2.4}{La compl\351tion d'automates d'arbres}{chapter.2}% 11
\BOOKMARK [0][-]{chapter.3}{D\351tection de contre-exemples et raffinement}{}% 12
\BOOKMARK [1][-]{section.3.1}{Fausses alarmes et contre-exemples}{chapter.3}% 13
\BOOKMARK [1][-]{section.3.2}{Principe de l'approche \340 la CEGAR appliqu\351 au model-checking r\351gulier}{chapter.3}% 14
\BOOKMARK [1][-]{section.3.3}{Contre-exemples et automates d'arbres}{chapter.3}% 15
\BOOKMARK [1][-]{section.3.4}{L'intuition initiale}{chapter.3}% 16
\BOOKMARK [1][-]{section.3.5}{D\351finition d'un R/E-automate}{chapter.3}% 17
\BOOKMARK [1][-]{section.3.6}{Construire un R/E-Automate pour le probl\350me d'atteignabilit\351}{chapter.3}% 18
\BOOKMARK [1][-]{section.3.7}{L'\351tape de R/E-compl\351tion C}{chapter.3}% 19
\BOOKMARK [1][-]{section.3.8}{La normalisation}{chapter.3}% 20
\BOOKMARK [1][-]{section.3.9}{R\351soudre le probl\350me du filtrage}{chapter.3}% 21
\BOOKMARK [1][-]{section.3.10}{L'\351tape de R/E-compl\351tion est correcte}{chapter.3}% 22
\BOOKMARK [1][-]{section.3.11}{L'acc\351l\351ration du calcul W}{chapter.3}% 23
\BOOKMARK [1][-]{section.3.12}{V\351rification de propri\351t\351s r\351guli\350res}{chapter.3}% 24
\BOOKMARK [1][-]{section.3.13}{Test de vacuit\351 de l'intersection}{chapter.3}% 25
\BOOKMARK [1][-]{section.3.14}{Raffiner l'approximation par \351lagage}{chapter.3}% 26
\BOOKMARK [1][-]{section.3.15}{R/E-compl\351tion et le calcul exact de termes atteignables}{chapter.3}% 27
\BOOKMARK [1][-]{section.3.16}{Conclusion}{chapter.3}% 28
\BOOKMARK [0][-]{chapter.4}{Preuves de propri\351t\351s temporelles sur TRS}{}% 29
\BOOKMARK [1][-]{section.4.1}{Du ByteCode Java \340 la r\351\351criture}{chapter.4}% 30
\BOOKMARK [1][-]{section.4.2}{Completion d'automates d'arbres et "044BRp/E}{chapter.4}% 31
\BOOKMARK [1][-]{section.4.3}{Extraction d'une structure de Kripke}{chapter.4}% 32
\BOOKMARK [1][-]{section.4.4}{Une logique temporelle portant des automates d'arbres}{chapter.4}% 33
\BOOKMARK [1][-]{section.4.5}{Conclusion, discussion}{chapter.4}% 34
\BOOKMARK [0][-]{chapter.5}{Certification de la compl\351tion d'automates d'arbres}{}% 35
\BOOKMARK [1][-]{section.5.1}{Un validateur de r\351sultat pour la compl\351tion d'automates d'arbres}{chapter.5}% 36
\BOOKMARK [1][-]{section.5.2}{Formalisation de la r\351\351criture}{chapter.5}% 37
\BOOKMARK [1][-]{section.5.3}{Formalisation des automates d'arbres}{chapter.5}% 38
\BOOKMARK [1][-]{section.5.4}{L'inclusion efficace d'automates}{chapter.5}% 39
\BOOKMARK [1][-]{section.5.5}{Formalisation de la cl\364ture par r\351\351criture}{chapter.5}% 40
\BOOKMARK [1][-]{section.5.6}{Conclusion}{chapter.5}% 41
\BOOKMARK [0][-]{section*.18}{Bibliographie g\351n\351rale}{}% 42
